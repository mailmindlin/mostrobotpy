---
extra_includes:
  - rpy/geometryToString.h
  - wpystruct.h

functions:
  to_json:
    ignore: true
  from_json:
    ignore: true
classes:
  Transform3d:
    shared_ptr: false
    methods:
      Transform3d:
        overloads:
          Pose3d, Pose3d:
          Translation3d, Rotation3d:
          units::meter_t, units::meter_t, units::meter_t, Rotation3d:
          '[constexpr]':
      Translation:
      X:
      Y:
      Z:
      Rotation:
      Inverse:
      operator*:
      operator/:
      operator+:
      operator==:
      operator!=:


inline_code: |
  cls_Transform3d
    .def_property_readonly("x", &Transform3d::X)
    .def_property_readonly("y", &Transform3d::Y)
    .def_property_readonly("z", &Transform3d::Z)
    .def_property_readonly("x_feet", [](const Transform3d * self) -> units::foot_t {
      return self->X();
    })
    .def_property_readonly("y_feet", [](const Transform3d * self) -> units::foot_t {
      return self->Y();
    })
    .def_property_readonly("z_feet", [](const Transform3d * self) -> units::foot_t {
      return self->Z();
    })
    .def("__repr__", py::overload_cast<const Transform3d&>(&rpy::toString))
    .def(py::pickle(
      [](const Transform3d &self) { // __getstate__
        auto q = self.Rotation().GetQuaternion();
        return py::make_tuple(self.X(), self.Y(), self.Z(), q.W(), q.X(), q.Y(), q.Z());
      },
      [](py::tuple t) { // __setstate__
        if (t.size() != 7)
          throw std::runtime_error("Invalid state!");
        
        return Transform3d(
          t[0].cast<units::meter_t>(),
          t[1].cast<units::meter_t>(),
          t[2].cast<units::meter_t>(),
          Rotation3d(
            Quaternion(
              t[3].cast<double>(),
              t[4].cast<double>(),
              t[5].cast<double>(),
              t[6].cast<double>()
            )
          )
        );
      }
    ))
  ;

  SetupWPyStruct<frc::Transform3d>(cls_Transform3d);
